/*generated by deepseek*/
#include "src/transport/scheduler/xqc_scheduler_sttf.h"
#include "src/transport/scheduler/xqc_scheduler_common.h"
#include "src/transport/xqc_send_ctl.h"


static size_t
xqc_sttf_scheduler_size()
{
    return 0;
}

static void
xqc_sttf_scheduler_init(void *scheduler, xqc_log_t *log, xqc_scheduler_params_t *param)
{
    return;
}

xqc_path_ctx_t *
xqc_sttf_scheduler_get_path(void *scheduler,
                            xqc_connection_t *conn, xqc_packet_out_t *packet_out, int check_cwnd, int reinject,
                            xqc_bool_t *cc_blocked)
{
    xqc_path_ctx_t *best_path = NULL;
    xqc_path_ctx_t *path;
    xqc_list_head_t *pos, *next;

    /* STTF metrics */
    uint64_t min_transmission_time = UINT64_MAX;
    uint64_t path_transmission_time;
    uint64_t path_srtt;
    uint64_t path_bw;
    uint64_t path_cwnd;
    uint64_t bytes_in_flight;
    uint64_t available_capacity;
    xqc_bool_t path_can_send = XQC_FALSE;
    xqc_bool_t reached_cwnd_check = XQC_FALSE;

    if (cc_blocked) {
        *cc_blocked = XQC_FALSE;
    }

    xqc_list_for_each_safe(pos, next, &conn->conn_paths_list) {
        path = xqc_list_entry(pos, xqc_path_ctx_t, path_list);

        /* skip inactive paths */
        /* skip frozen paths */
        if (path->path_state != XQC_PATH_STATE_ACTIVE
            || path->app_path_status == XQC_APP_PATH_STATUS_FROZEN
            || (reinject && (packet_out->po_path_id == path->path_id)))
        {
            continue;
        }

        if (!reached_cwnd_check) {
            reached_cwnd_check = XQC_TRUE;
            if (cc_blocked) {
                *cc_blocked = XQC_TRUE;
            }
        }

        /* check if path can send (considering congestion window) */
        path_can_send = xqc_scheduler_check_path_can_send(path, packet_out, check_cwnd);

        if (!path_can_send) {
            continue;
        }

        if (cc_blocked) {
            *cc_blocked = XQC_FALSE;
        }

        /* Get path metrics for STTF calculation */
        path_srtt = xqc_send_ctl_get_srtt(path->path_send_ctl);
        path_bw = xqc_send_ctl_get_est_bw(path->path_send_ctl);
        path_cwnd = path->path_send_ctl->ctl_cong_callback->xqc_cong_ctl_get_cwnd(path->path_send_ctl->ctl_cong);
        bytes_in_flight = path->path_send_ctl->ctl_bytes_in_flight;

        /* Calculate available capacity (cwnd - bytes_in_flight) */
        available_capacity = (bytes_in_flight < path_cwnd) ?
        (path_cwnd - bytes_in_flight) : 0;

        /* STTF calculation:
         * transmission_time = srtt + (packet_size / available_bandwidth)
         * available_bandwidth = min(path_bw, available_capacity / srtt)
         */
        if (path_bw > 0 && available_capacity > 0) {
            uint64_t available_bandwidth = xqc_min(path_bw,
                                                   (available_capacity * 1000000) / (path_srtt > 0 ? path_srtt : 1));

            path_transmission_time = path_srtt +
            (packet_out->po_used_size * 1000000) / (available_bandwidth > 0 ? available_bandwidth : 1);
        } else {
            /* If bandwidth is zero, use srtt as fallback */
            path_transmission_time = path_srtt;
        }

        xqc_log(conn->log, XQC_LOG_DEBUG,
                "|STTF metrics|conn:%p|path_id:%ui|srtt:%ui|bw:%ui|cwnd:%ui|"
                "inflight:%ui|avail_cap:%ui|trans_time:%ui|can_send:%d|",
                conn, path->path_id, path_srtt, path_bw, path_cwnd,
                bytes_in_flight, available_capacity, path_transmission_time, path_can_send);

        /* Select path with minimum transmission time */
        if (best_path == NULL || path_transmission_time < min_transmission_time) {
            best_path = path;
            min_transmission_time = path_transmission_time;
        }
    }

    if (best_path != NULL) {
        xqc_log(conn->log, XQC_LOG_DEBUG, "|STTF selected path:%ui|frame_type:%s|"
        "pn:%ui|size:%ud|reinj:%d|trans_time:%ui|",
        best_path->path_id,
        xqc_frame_type_2_str(conn->engine, packet_out->po_frame_types),
                packet_out->po_pkt.pkt_num,
                packet_out->po_used_size, reinject, min_transmission_time);
        return best_path;
    }

    xqc_log(conn->log, XQC_LOG_DEBUG, "|No available paths to schedule|conn:%p|", conn);
    return NULL;
}

const xqc_scheduler_callback_t xqc_sttf_scheduler_cb = {
    .xqc_scheduler_size             = xqc_sttf_scheduler_size,
    .xqc_scheduler_init             = xqc_sttf_scheduler_init,
    .xqc_scheduler_get_path         = xqc_sttf_scheduler_get_path,
};
